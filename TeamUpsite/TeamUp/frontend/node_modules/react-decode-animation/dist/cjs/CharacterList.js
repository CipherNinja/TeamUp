"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CharacterList = void 0;
const constants_1 = require("./constants");
class CharacterList {
    constructor(allowedCharacters, custom) {
        if (custom && custom.trim() !== "") {
            this.characters = CharacterList.toCharacters(custom, false);
            return;
        }
        if (!allowedCharacters) {
            allowedCharacters = ["uppercase", "lowercase"];
        }
        let charsList = "";
        if (typeof allowedCharacters === "string") {
            charsList = allowedCharacters;
        }
        else {
            allowedCharacters.forEach((chars) => {
                switch (chars) {
                    case "lowercase":
                        charsList += constants_1.ALLOWED_CHARACTERS.lowercase;
                        break;
                    case "uppercase":
                        charsList += constants_1.ALLOWED_CHARACTERS.uppercase;
                        break;
                    case "numbers":
                        charsList += constants_1.ALLOWED_CHARACTERS.numbers;
                        break;
                    case "symbols":
                        charsList += constants_1.ALLOWED_CHARACTERS.symbols;
                        break;
                }
            });
        }
        this.characters = CharacterList.toCharacters(charsList, false);
    }
    static *generateCode(loopString) {
        for (let index = 0; index < loopString.length; index++) {
            yield loopString[index];
            if (index + 1 >= loopString.length) {
                index = 0;
            }
        }
    }
    shuffle() {
        let characters = this.characters;
        let index = characters.length, randomIndex;
        while (index != 0) {
            randomIndex = Math.floor(Math.random() * index);
            index--;
            [characters[index], characters[randomIndex]] = [
                characters[randomIndex],
                characters[index],
            ];
        }
        return characters.join("");
    }
    static toCharacters(value, allowDuplicates = true) {
        const array = Array.from(value);
        return allowDuplicates ? array : Array.from(new Set(array));
    }
}
exports.CharacterList = CharacterList;
//# sourceMappingURL=CharacterList.js.map